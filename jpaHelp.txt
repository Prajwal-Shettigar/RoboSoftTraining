


create entity manager factory using the persistance class

using entity manager factory create a entity manager

then using entity manager perform database operations

annotate the class as entity and also annotate the id

use javax class


dependencies needed for hibernate
	<dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>5.6.10.Final</version>
        </dependency>
	 <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.30</version>
        </dependency>


persistance xml file   persistence.xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
          http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd"
             version="2.2">

<persistence-unit name="default">
    <properties>
        <property name="javax.persistence.jdbc.driver" value="com.mysql.cj.jdbc.Driver" />
        <property name="javax.persistence.jdbc.url"
                  value="jdbc:mysql://localhost:3306/forjpa" />
        <property name="javax.persistence.jdbc.user" value="root" />
        <property name="javax.persistence.jdbc.password"
                  value="root" />

    </properties>
</persistence-unit>
</persistence>


place it under resources/META-INF folder

create a db and also a table in database


dependencies for jpa
<dependencies>
        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
            <version>2.7.2</version>
        </dependency>

        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <version>2.7.3</version>
        </dependency>


        <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.30</version>
        </dependency>

        <dependency>
            <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>
            <version>2.3.0</version>
        </dependency>


        <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.24</version>
            <scope>provided</scope>
        </dependency>


use mysql5dialect


application.properties file
spring.datasource.url=jdbc:mysql://localhost:3306/forjpa
spring.datasource.username=root
spring.datasource.password=root
spring.jpa.database-platform = org.hibernate.dialect.MySQL5Dialect
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto = update




@Query can be used for mentioning ur own queries for methods in jpaRepository

@Modifying can beb used for creating sql stateemnts which modify the table such as delete has to be used in combination with @Query and also annotate with @Transactional
@Transactional
@Modying
@Query(value="mention query here",nativeQuery=true)


    @Transactional
    @Modifying
    @Query(value = "delete from employee e where e.city=?1",nativeQuery = true)
    void deleteByCity(String city);



@NamedNativeQuery(name = "Employee.findByNameandCity",query ="select * from employee  where name=?1 and city=?2",resultClass = Employee.class)
useful for mentioning queries along with the entity and can create a method with the same name in jparepositiory which can be directly called


@OneToOne
can be both unidirectinal and bidirectional 
in unidirectional u create the foreign key which references the primary key of the other table
in bidirectional u apply the relation ship in both tables
u can also use mapped by if u have created variables for foreign key in both classes like bidirectional


//for data format exception
while using bidirectional relationships use
@JsonBackReference on the variable which will not map
@JsonManagedReference on variable which will map
u also need to mention the mapped by
and @JsonIgnore on variable which is used for mapping

to change server port in spring boot add server.port=port number


RestTemplate can just act as a client and just accept the data from server just like postman and also send data to server


@OneToOne here one entity of A is related to atmost one entity of b so u would require a foreign key in either A or B

@OneToOne(mappedBy=)   spcify mapped by if bidirectional
@JoinColumn()specify the name of the column which would be used as foreign key mention this over the varibale of entity which is going to have the foreign key


@OneToMany  one column of A is related to multiple columns of B
@ManyToOne multiple columns of A are related to one column of B

if one to many from A then B needs to have the foreign key so use mapped by in A and and specify the join column tag in B

@ManyToMany 
multiple records of A are related to multiple records of B
a new table has to be created with 2 foreign keys from both A and B
specify the tag over variables of both entities and specify @JoinTable to specify name and other properties of table and mapped by to specify which entity is responsible to create the table




@OneToOne
using in both entities can create foreign key columns in both tables
using in both entities but mentioning in one mappedBy the other can create a foreign key in only the entity in which mappedBy is not mentioned
if used in only one table then foreign key will  be created in the mentioned table

@OneToMany  && @ManyToOne
using in just one entity creates a new table where u have the primary key of mentioned tables as foreign key and primary key of other table as primary key

if @OneToMany and @ManyToOne is mentioned then @OneToMany will create a table with 2 foreign keys and @ManyToOne will add a foreign key to the used table

using mappedby in @OneToMany will create a foreign key column in the other table


@ManyToMany
using in just one entity will create a table with 2 foreign keys
using in both entities will create 2 similar tables with 2 foreign keys
using mapped by in any one will create a single table with 2 foreign keys


setting default values to columns
 @Column(columnDefinition = "varchar(255) default null")
mention hte datatype as well otherwise might give syntax error

use jakarta with java17 or above

@PostLoad 
used to load the value of a variable after all the variables in class have been intialized

@PrePersist
used to assign a value to the variable before sending it to the database

@Transient
will not be mapped onto the database


creating a composite primary key
@Embeddable
public class DishRestaurantKey implements Serializable {

    private Integer dishId;

    private Integer restaurantId;
}

@Entity
public class Menu {

    @EmbeddedId
    DishRestaurantKey id;

    @ManyToOne
    @JoinColumn(name="restaurant_id")
    @MapsId(value="restaurantId")
    Restaurant restaurant;

    @ManyToOne
    @JoinColumn(name="dish_id")
    @MapsId(value="dishId")
    Dish dish;



}

//auto generated string column


    @Id
    @GeneratedValue(generator = "uuid")
    @GenericGenerator(name="uuid" , strategy = "uuid2")
    private String cardNumber;


//beautify the sql statements in spring boot for jpa


//using pagination
//2nd page of size 20
Page<User> users = repository.findAll(PageRequest.of(1, 20));


//crud vs list crud

basically these repos contains crud functionalities but list crude returns an list in place of iterable in certain large result set returning methods

 List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);

  // Enables the distinct flag for the query
  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);

  // Enabling ignoring case for an individual property
  List<Person> findByLastnameIgnoreCase(String lastname);
  // Enabling ignoring case for all suitable properties
  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);

  // Enabling static ORDER BY for a query
  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);
  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);

could have distinct or top ,firstv between find and by

can have between ,less than,greater than,like with properties attached which will be seperatred by and or or

ignore case
use ignore case like findByLastNameIgnoreCase  or findByFirstNameAndLastNameAllIgnoreCase iff multiple/all properties among the query supports ignore case

traverse a property within another
List<Person> findByAddress_ZipCode(ZipCode zipCode);  traverse zipcode within address property of the entity

If you do not want to apply any sorting or pagination, use Sort.unsorted() and Pageable.unpaged().

sorting

Sort sort = Sort.by("firstname").ascending()
  .and(Sort.by("lastname").descending());


type safe sort
TypedSort<Person> person = Sort.sort(Person.class);

Sort sort = person.by(Person::getFirstname).ascending()
  .and(person.by(Person::getLastname).descending());

//using first or top
//if u dont specify size its default 1

User findFirstByOrderByLastnameAsc();

User findTopByOrderByAgeDesc();

Page<User> queryFirst10ByLastname(String lastname, Pageable pageable);

Slice<User> findTop3ByLastname(String lastname, Pageable pageable);

List<User> findFirst10ByLastname(String lastname, Sort sort);

List<User> findTop10ByLastname(String lastname, Pageable pageable);


//returning a streamable
interface PersonRepository extends Repository<Person, Long> {
  Streamable<Person> findByFirstnameContaining(String firstname);
  Streamable<Person> findByLastnameContaining(String lastname);
}

Streamable<Person> result = repository.findByFirstnameContaining("av")
  .and(repository.findByLastnameContaining("ea"));

returning custom streamable


Repository methods returning collections, collection alternatives, wrappers, and streams are guaranteed never to return null but rather the corresponding empty representation.

<jpa:repositories base-package="com.acme.repositories" />